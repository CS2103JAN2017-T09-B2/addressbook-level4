# A0139926R
###### \java\typetask\commons\core\Messages.java
``` java
    public static final String MESSAGE_INVALID_START_AND_END_DATE =
            "End date and time should not be before Start date and time";
    public static final String MESSAGE_INVALID_DATE_FORMAT_FOR_START_DATE = "Start date is invalid";
    public static final String MESSAGE_INVALID_DATE_FORMAT_FOR_END_DATE = "End date is invalid";
    public static final String MESSAGE_INVALID_DATE_FORMAT_FOR_DATE = "Deadline is invalid";

}
```
###### \java\typetask\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the TaskManager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";
    public static final String COMMAND_WORD2 = "a";
    public static final String COMMAND_WORD3 = "+";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Adds a task with or without date to the task list. \n"
            + "<> means compulsory [] means optional \n"
            + "Parameters: \"<NAME> by:[DATE][TIME]\"   "
            + "\"<NAME> from:[DATE][TIME] to: [DATE][TIME]\" \n"
            + "Example: " + COMMAND_WORD
            + " Read Harry Potter book 1 ";

```
###### \java\typetask\logic\commands\AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    //Creates a Floating Task
    public AddCommand(String name)
            throws IllegalValueException {
        this.toAdd = new Task(new Name(name), new DueDate(""), new DueDate(""), false);
    }
    //Creates a Deadline Task
    public AddCommand(String name, String dateTime)
            throws IllegalValueException {
        this.toAdd = new Task(new Name(name), new DueDate(""), new DueDate(dateTime), false);
    }
    //Creates an Event
    public AddCommand(String name, String date, String endDate)
            throws IllegalValueException {
        this.toAdd = new Task(new Name(name), new DueDate(date), new DueDate(endDate), false);
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        model.storeTaskManager(COMMAND_WORD);
        model.addTask(toAdd);
        return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
    }

}
```
###### \java\typetask\logic\commands\EditCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
        model.storeTaskManager(COMMAND_WORD);
        model.updateTask(filteredTaskListIndex, editedTask);
        model.updateFilteredTaskList(false);
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }
```
###### \java\typetask\logic\commands\EditCommand.java
``` java
    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit,
                                             EditTaskDescriptor editTaskDescriptor) {
        assert taskToEdit != null;

        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        DueDate updatedDate = editTaskDescriptor.getDate().orElseGet(taskToEdit::getDate);
        DueDate updatedEndDate = editTaskDescriptor.getEndDate().orElseGet(taskToEdit::getEndDate);

        return new Task(updatedName, updatedDate, updatedEndDate, false);
    }
```
###### \java\typetask\logic\commands\EditCommand.java
``` java
    /**
     * Stores the details to edit the task with. Each non-empty field value will replace the
     * corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<DueDate> date = Optional.empty();
        private Optional<DueDate> endDate = Optional.empty();

        public EditTaskDescriptor() {}

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.name = toCopy.getName();
            this.date = toCopy.getDate();
            this.endDate = toCopy.getEndDate();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.name, this.date,
                    this.endDate);
        }

        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public Optional<Name> getName() {
            return name;
        }

        public void setDate(Optional<DueDate> date) {
            assert date != null;
            this.date = date;
        }
        public void setEndDate(Optional<DueDate> endDate) {
            assert endDate != null;
            this.endDate = endDate;
        }

        public Optional<DueDate> getDate() {
            return date;
        }
        public Optional<DueDate> getEndDate() {
            return endDate;
        }

    }
}
```
###### \java\typetask\logic\commands\RedoCommand.java
``` java
/**
 * Redo recent command entered.
 */
public class RedoCommand extends Command {
    public static final String COMMAND_WORD = "redo";
    public static final String COMMAND_WORD_SHORT = "r";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Redo a command that was previously undone." + "Example: "
            + COMMAND_WORD;
    public static final String MESSAGE_SUCCESS = "Redo previous command.";
    public static final String MESSAGE_FAILURE = "There is no command to redo.";

    private static final int STATUS_EMPTY_HISTORY = 0;
    private static final int STATUS_ERROR_HISTORY = -1;

    @Override
    /**
     * Returns failure if there is no undo command executed before, otherwise returns true
     */
    public CommandResult execute() {
        switch (model.revertTaskManager()) {
        case STATUS_ERROR_HISTORY:
            return new CommandResult(MESSAGE_FAILURE);
        case STATUS_EMPTY_HISTORY:
            return new CommandResult(MESSAGE_FAILURE);
        default:
            return new CommandResult(MESSAGE_SUCCESS);
        }
    }
}
```
###### \java\typetask\logic\commands\RemoveDeadlineCommand.java
``` java
/**
 * Remove all the date and time for a task
 */
public class RemoveDeadlineCommand extends Command {

    public static final String COMMAND_WORD = "removedeadline";
    public static final String COMMAND_WORD_SHORT = "rd";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Removes the deadline of the task identified "
            + "by the index number used in the last task listing. "
            + "Parameters: INDEX \n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    private final int filteredTaskListIndex;

    public RemoveDeadlineCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask = createEditedTask(taskToEdit);
        model.storeTaskManager(COMMAND_WORD);
        model.updateTask(filteredTaskListIndex, editedTask);
        model.updateFilteredTaskList(false);
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    private static Task createEditedTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;

        Name updatedName = taskToEdit.getName();
        DueDate updatedDate = taskToEdit.getDate();
        DueDate updatedEndDate = taskToEdit.getEndDate();
        try {
            updatedDate = new DueDate("");
            updatedEndDate = new DueDate("");
        } catch (IllegalValueException e) {
        }
        return new Task(updatedName, updatedDate, updatedEndDate, false);
    }
}
```
###### \java\typetask\logic\commands\UndoCommand.java
``` java
/**
 * Undo recent command entered.
 * Undo commands that makes modification to data
 * E.g add,delete,edit,clear,done
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String COMMAND_WORD_SHORT = "u";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo the most recent command." + "\n\nExample: "
            + COMMAND_WORD;
    public static final String MESSAGE_SUCCESS = "Restored previous command.";
    public static final String MESSAGE_FAILURE = "No previous command to undo";

    private static final int STATUS_EMPTY_HISTORY = 0;
    private static final int STATUS_ERROR_HISTORY = -1;

    /**
     * Returns failure if there is no command executed before
     * Returns success if a command is found to be executed before this command
     */
    @Override
    public CommandResult execute() {
        switch (model.restoreTaskManager()) {
        case STATUS_ERROR_HISTORY:
            return new CommandResult(MESSAGE_FAILURE);
        case STATUS_EMPTY_HISTORY:
            return new CommandResult(MESSAGE_FAILURE);
        default:
            return new CommandResult(MESSAGE_SUCCESS);
        }
    }
}
```
###### \java\typetask\logic\parser\AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {
    private final int floatingTask = 0;
    private final int deadlineTaskWithTime = 1;
    private final int deadlineTaskWithDate = 2;
    private final int eventTask = 3;
    private final int invalidEvent = 4;
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_DATE, PREFIX_TIME, PREFIX_START_DATE, PREFIX_END_DATE);
        argsTokenizer.tokenize(args);
        try {
            int taskType = checkTaskType(argsTokenizer);
            return getCorrectAddCommand(argsTokenizer, taskType);

        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    private Command getCorrectAddCommand(ArgumentTokenizer argsTokenizer, int taskType) throws IllegalValueException {
        if (taskType == eventTask) {
            List<Date> startDate = DateParser.getDate(argsTokenizer.getValue(PREFIX_START_DATE).get());
            List<Date> endDate = DateParser.getDate(argsTokenizer.getValue(PREFIX_END_DATE).get());
            if (!DateParser.checkValidDateFormat(startDate)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_DATE_FORMAT_FOR_START_DATE));
            }
            if (!DateParser.checkValidDateFormat(endDate)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_DATE_FORMAT_FOR_END_DATE));
            }
            if (DateParser.checkValidSchedule(startDate, endDate)) {
                return new AddCommand(
                        argsTokenizer.getPreamble().get(),
                        DateParser.getDateString(startDate),
                        DateParser.getDateString(endDate)
                        );
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_START_AND_END_DATE));
            }
        } else if (taskType == deadlineTaskWithDate) {
            List<Date> deadline = DateParser.getDate(argsTokenizer.getValue(PREFIX_DATE).get());
            if (!DateParser.checkValidDateFormat(deadline)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_DATE_FORMAT_FOR_DATE));
            }
            return new AddCommand(
                    argsTokenizer.getPreamble().get(),
                    DateParser.getDateString(deadline)
                    );
        } else if (taskType == deadlineTaskWithTime) {
            List<Date> deadline = DateParser.getDate(argsTokenizer.getValue(PREFIX_TIME).get());
            if (!DateParser.checkValidDateFormat(deadline)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_DATE_FORMAT_FOR_DATE));
            }
            return new AddCommand(
                    argsTokenizer.getPreamble().get(),
                    DateParser.getDateString(deadline)
                    );
        } else if (taskType == invalidEvent) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } else {
            return new AddCommand(
                    argsTokenizer.getPreamble().get()
                    );
        }
    }
```
###### \java\typetask\logic\parser\AddCommandParser.java
``` java
    public int checkTaskType(ArgumentTokenizer argsTokenizer) {
        if (argsTokenizer.getValue(PREFIX_START_DATE).isPresent() &&
                argsTokenizer.getValue(PREFIX_END_DATE).isPresent()) {
            return eventTask;
        } else if (argsTokenizer.getValue(PREFIX_DATE).isPresent()) {
            return deadlineTaskWithDate;
        } else if (argsTokenizer.getValue(PREFIX_TIME).isPresent()) {
            return deadlineTaskWithTime;
        } else if (argsTokenizer.getValue(PREFIX_START_DATE).isPresent() ||
                argsTokenizer.getValue(PREFIX_END_DATE).isPresent()) {
            return invalidEvent;
        } else {
            return floatingTask;
        }
    }

}
```
###### \java\typetask\logic\parser\CliSyntax.java
``` java
/**
 * Contains Command Line Interface (CLI) syntax definitions common to multiple commands
 */
public class CliSyntax {

    /* Prefix definitions */
    public static final Prefix PREFIX_DATE = new Prefix("by:");
    public static final Prefix PREFIX_TIME = new Prefix("@");
    public static final Prefix PREFIX_START_DATE = new Prefix("from:");
    public static final Prefix PREFIX_END_DATE = new Prefix("to:");

    /* Patterns definitions */
    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace

}
```
###### \java\typetask\logic\parser\DateParser.java
``` java
/**
 * Parser class for handling date and time using the
 * Natty library.
 * @author Abel
 *
 */
public class DateParser {

    private static final int day = 0;
    private static final int month = 1;
    private static final int dayDate = 2;
    private static final int time = 3;
    private static final int year = 5;
    private static final int dateFromUser = 0;
    /**
     * Private constructor to prevent instantiation.
     */
    private DateParser() {
    }

    /**
     * Parses given date and time string and returns
     * an array of date time that we are interested in capturing.
     * Usually start and end dates or just deadline date.
     * If no dates are found, empty list is returned.
     * @param dateTimeString String containing date and time to be parsed.
     * @return A list of Dates found in String.
     */
    public static List<Date> parse(String dateTimeString) {
        assert dateTimeString != null && !dateTimeString.isEmpty();
        Parser parser = new Parser(TimeZone.getDefault());
        List<DateGroup> groups = parser.parse(dateTimeString);
        if (groups.isEmpty() || groups.get(0) == null) {
            return new ArrayList<>();
        }


        DateGroup group = groups.get(dateFromUser);
        List<Date> dates = group.getDates();

        // If time is inferred and not explicitly stated by user
        // Reset time because it would produce the current time
        boolean isTimeInferred = group.isTimeInferred();
        if (isTimeInferred) {
            resetTime(dates);
        }

        return dates;
    }

    /**
     * Resets the time fields in the list of dates to zeroes.
     * @param dates List of dates to be reset.
     */
    private static void resetTime(List<Date> dates) {
        if (dates == null) {
            return;
        }

        for (Date date: dates) {
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(date);
            calendar.set(Calendar.HOUR_OF_DAY, 23);
            calendar.set(Calendar.MINUTE, 59);
            calendar.set(Calendar.SECOND, 59);
            calendar.set(Calendar.MILLISECOND, 0);
            date.setTime(calendar.getTime().getTime());
        }
    }
```
###### \java\typetask\logic\parser\DateParser.java
``` java
    /**
     * Uses @param date to get date and time
     * @return list of dates
     */
    public static List<Date> getDate(String date) {
        assert date != null;
        List<Date> dates = DateParser.parse(date);
        return dates;
    }
    /**
     * Gets the list of dates from @param dates
     * @return date in String format
     */
    public static String getDateString(List<Date> dates) {
        String finalizedDate;
        String nattyDate = dates.get(dateFromUser).toString();
        String[] splitDate = nattyDate.split(" ");
        finalizedDate = splitDate[day] + " " + splitDate[month] + " " + splitDate[dayDate] +
                " " + splitDate[year] + " " + splitDate[time];
        return finalizedDate;
    }
    /**
     * Compares @param startDate and @param endDate
     * Checks event schedule
     * Checks only if there is a startDate and endDate
     * @return true if endDate is not before startDate, otherwise false
     */
    public static boolean checkValidSchedule(List<Date> startDate, List<Date> endDate) {
        boolean isValidDate = false;
        if (!startDate.isEmpty() && !endDate.isEmpty()) {
            Date sDate = startDate.get(dateFromUser);
            Date eDate = endDate.get(dateFromUser);
            isValidDate = checkValidEventDate(sDate, eDate);
        }
        return isValidDate;
    }
    /**
     * Compares @param startDate and @param endDate
     * @return true if endDate is not before startDate, otherwise false
     */
    public static boolean checkValidEventDate(Date startDate, Date endDate) {
        boolean isValidDate = false;
        if (startDate.before(endDate)) {
            isValidDate = true;
        }
        return isValidDate;
    }
    /**
     * Checks @param date if the list of dates is empty or not
     * @return true if there is a date in the list
     */
    public static boolean checkValidDateFormat(List<Date> date) {
        boolean isValidDate = false;
        if (!date.isEmpty()) {
            isValidDate = true;
        }
        return isValidDate;
    }

}
```
###### \java\typetask\logic\parser\EditCommandParser.java
``` java
/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser {

    private static final int day = 0;
    private static final int month = 1;
    private static final int dayDate = 2;
    private static final int time = 3;
    private static final int year = 5;
    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_DATE, PREFIX_TIME, PREFIX_START_DATE,
                        PREFIX_END_DATE);
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        try {
            editTaskDescriptor.setName(ParserUtil.parseName(preambleFields.get(1)));
            if (argsTokenizer.getValue(PREFIX_DATE).isPresent()) {
                Optional<String> parseDate = Optional.of(getDate(argsTokenizer.getValue(PREFIX_DATE).get()));
                Optional<String> emptyString = Optional.of("");
                editTaskDescriptor.setEndDate(ParserUtil.parseDate(parseDate));
                editTaskDescriptor.setDate(ParserUtil.parseDate(emptyString));
            }
            if (argsTokenizer.getValue(PREFIX_TIME).isPresent()) {
                Optional<String> parseDate = Optional.of(getDate(argsTokenizer.getValue(PREFIX_TIME).get()));
                editTaskDescriptor.setEndDate(ParserUtil.parseDate(parseDate));
            }
            if (argsTokenizer.getValue(PREFIX_END_DATE).isPresent()) {
                Optional<String> parseDate = Optional.of(getDate(argsTokenizer.getValue(PREFIX_END_DATE).get()));
                editTaskDescriptor.setEndDate(ParserUtil.parseDate(parseDate));
            }
            if (argsTokenizer.getValue(PREFIX_START_DATE).isPresent()) {
                Optional<String> parseDate = Optional.of(getDate(argsTokenizer.getValue(PREFIX_START_DATE).get()));
                editTaskDescriptor.setDate(ParserUtil.parseDate(parseDate));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }

        return new EditCommand(index.get(), editTaskDescriptor);
    }
```
###### \java\typetask\logic\parser\EditCommandParser.java
``` java
    public String getDate(String date) {
        if (date.isEmpty()) {
            return "";
        }
        List<Date> dates = DateParser.parse(date);
        String nattyDate = dates.get(0).toString();
        String[] splitDate = nattyDate.split(" ");
        String finalizedDate = splitDate[day] + " " + splitDate[month] + " " + splitDate[dayDate] +
                " " + splitDate[year] + " " + splitDate[time];
        return finalizedDate;
    }

}
```
###### \java\typetask\logic\parser\Parser.java
``` java
        case UndoCommand.COMMAND_WORD:
            return new UndoCommandParser().parse();
        case UndoCommand.COMMAND_WORD_SHORT:
            return new UndoCommandParser().parse();

        case RedoCommand.COMMAND_WORD:
            return new RedoCommandParser().parse();
        case RedoCommand.COMMAND_WORD_SHORT:
            return new RedoCommandParser().parse();

        case RemoveDeadlineCommand.COMMAND_WORD:
            return new RemoveDeadlineCommandParser().parse(arguments);
        case RemoveDeadlineCommand.COMMAND_WORD_SHORT:
            return new RemoveDeadlineCommandParser().parse(arguments);

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }

}
```
###### \java\typetask\logic\parser\RedoCommandParser.java
``` java
/**
 * Creates a new RedoCommand object
 */
public class RedoCommandParser {

    public Command parse() {
        return new RedoCommand();
    }
}
```
###### \java\typetask\logic\parser\RemoveDeadlineCommandParser.java
``` java
/**
 * Parses input arguments and creates a new RemoveDeadlineCommand object
 */
public class RemoveDeadlineCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an RemoveDeadlineCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    RemoveDeadlineCommand.MESSAGE_USAGE));
        }

        return new RemoveDeadlineCommand(index.get());
    }
}
```
###### \java\typetask\logic\parser\UndoCommandParser.java
``` java
/**
 * Creates a new UndoCommand object
 */
public class UndoCommandParser {

    public Command parse() {
        return new UndoCommand();
    }
}
```
###### \java\typetask\model\Model.java
``` java
    /** Stores current TaskManager state */
    void storeTaskManager(String command);

    /** Restores most recently stored TaskManager state */
    int restoreTaskManager();

    /** Undo most recently restored TaskManager state */
    int revertTaskManager();

    /** Removes most recently stored TaskManager state upon fail in check */
    void rollBackTaskManager(boolean isStorageOperation);

}
```
###### \java\typetask\model\ModelManager.java
``` java
    private Stack<TaskManager> taskManagerHistory = new Stack<TaskManager>();
    private Stack<TaskManager> redoTaskManagerHistory = new Stack<TaskManager>();

    public static final Integer STATUS_EMPTY_HISTORY = 0;
    public static final Integer STATUS_AVAILABLE_HISTORY = 1;
    public static final Integer STATUS_ERROR_HISTORY = -1;
```
###### \java\typetask\model\ModelManager.java
``` java
    /**
     * Stores current TaskManager state for undo and redo features
     */
    @Override
    public synchronized void storeTaskManager(String command) {

        StorageUtil.storeConfig(null);
        taskManagerHistory.push(new TaskManager(taskManager));
        redoTaskManagerHistory.clear();
        StorageUtil.clearRedoConfig();
    }
```
###### \java\typetask\model\ModelManager.java
``` java
    /**
     * Reverts changes made from restoring recently saved TaskManager state for redo command
     */
    @Override
    public synchronized int revertTaskManager() {
        if (StorageUtil.isRedoConfigHistoryEmpty() && redoTaskManagerHistory.isEmpty()) {
            return STATUS_EMPTY_HISTORY;
        } else if (!redoTaskManagerHistory.isEmpty() && redoTaskManagerHistory.peek() == null) {
            redoTaskManagerHistory.pop();
            taskManagerHistory.push(null);
            return STATUS_AVAILABLE_HISTORY;
        } else {
            TaskManager redoTaskManager = redoTaskManagerHistory.pop();
            taskManagerHistory.push(new TaskManager(taskManager));
            this.resetData(redoTaskManager);
            return STATUS_AVAILABLE_HISTORY;
        }
    }
```
###### \java\typetask\model\ModelManager.java
``` java
    /**
     * Restores recently saved TaskManager state for undo command
     */
    @Override
    public synchronized int restoreTaskManager() {
        if (StorageUtil.isConfigHistoryEmpty() && taskManagerHistory.isEmpty()) {
            return STATUS_EMPTY_HISTORY;
        } else if (!taskManagerHistory.isEmpty() && taskManagerHistory.peek() == null) {
            taskManagerHistory.pop();
            redoTaskManagerHistory.push(null);
            return STATUS_AVAILABLE_HISTORY;
        } else {
            TaskManager recentTaskManager = taskManagerHistory.pop();
            redoTaskManagerHistory.push(new TaskManager(taskManager));
            this.resetData(recentTaskManager);
            return STATUS_AVAILABLE_HISTORY;
        }

    }
```
###### \java\typetask\model\ModelManager.java
``` java
    /**
     * Restores configuration to the previous configuration
     * Not implemented yet
     */
    @Override
    public synchronized void rollBackTaskManager(boolean isStorageOperation) {

        taskManagerHistory.pop();
        if (isStorageOperation) {
            StorageUtil.undoConfig();
        }
    }
    //=========== Filtered Task List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }
```
###### \java\typetask\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            boolean result = false;
            boolean date = false;
            boolean endDate = false;
            boolean name = false;
            date = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getDate().value, keyword))
                    .findAny()
                    .isPresent();
            endDate = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getEndDate().value, keyword))
                    .findAny()
                    .isPresent();
            name = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword))
                    .findAny()
                    .isPresent();
            if (date || endDate || name) {
                result = true;
            }
            return result;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

```
###### \java\typetask\model\task\DueDate.java
``` java
public class DueDate {
    public static final String MESSAGE_DATE_CONSTRAINTS = "Examples of task's dates: by tmr , today, next week 5pm";
    public final String value;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public DueDate(String date) throws IllegalValueException {
        assert date != null;
        String trimmedDate = date.trim();
        this.value = trimmedDate;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DueDate // instanceof handles nulls
                && this.value.equals(((DueDate) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
}
```
###### \java\typetask\model\task\ReadOnlyTask.java
``` java
    DueDate getDate();
    DueDate getEndDate();
```
###### \java\typetask\model\task\Task.java
``` java
    /**
     * Every field must be present and not null.
     */
    public Task(Name name, DueDate date, DueDate endDate, boolean isCompleted) {
        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        this.date = date;
        this.endDate = endDate;
        this.isCompleted = isCompleted;
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
       this(source.getName(), source.getDate(), source.getEndDate(),
              source.getIsCompleted());
    }

    public void setName(Name name) {
        assert name != null;
        this.name = name;
    }

```
###### \java\typetask\model\task\Task.java
``` java
    public void setDate(DueDate date) {
        this.date = date;
    }
```
###### \java\typetask\model\task\Task.java
``` java
    public void setEndDate(DueDate endDate) {
        this.endDate = endDate;
    }


```
###### \java\typetask\model\task\Task.java
``` java
    @Override
    public DueDate getDate() {
        return date;
    }
```
###### \java\typetask\model\task\Task.java
``` java
    @Override
    public DueDate getEndDate() {
        return endDate;
    }

```
###### \java\typetask\model\task\Task.java
``` java

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;
        this.setName(replacement.getName());
        this.setDate(replacement.getDate());
        this.setEndDate(replacement.getEndDate());
    }
```
###### \java\typetask\storage\XmlAdaptedTask.java
``` java
    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String date;
    @XmlElement(required = true)
    private Boolean isCompleted;
    @XmlElement(required = true)
    private String endDate;


    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}

```
###### \java\typetask\storage\XmlAdaptedTask.java
``` java
    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        date = source.getDate().value;
        if (source.getEndDate() != null) {
            endDate = source.getEndDate().value;
        } else {
            endDate = "";
        }

        isCompleted = source.getIsCompleted();
    }
```
###### \java\typetask\storage\XmlAdaptedTask.java
``` java
    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final Name name = new Name(this.name);
        final DueDate date = new DueDate(this.date);
        final DueDate endDate = new DueDate(this.endDate);
        boolean isCompleted = false;
        if (this.isCompleted != null) {
            isCompleted = this.isCompleted;
        }
        return new Task(name, date, endDate, isCompleted);
    }
}
```
###### \java\typetask\ui\TaskCard.java
``` java
    /**
     * Takes @param task to check if this task is overdue or not
     * Compares using current date
     * Sets color for overdue task and pending task
     */
    private void setStatusForTask(ReadOnlyTask task) {
        if (!task.getEndDate().value.equals("")) {
            List<Date> dates = DateParser.parse(task.getEndDate().value);
            Date taskDeadline = dates.get(0);
            Calendar calendar = Calendar.getInstance();
            Date nowDate = calendar.getTime();
            if (nowDate.after(taskDeadline)) {
                setStyleToIndicateOverdue();
            } else {
                setStyleToIndicatePending();
            }
        }
    }



```
